# Chap 9 그래프 알고리즘
* 그래프: 노드 + 간선으로 구성되는 그림

## 그래프
* 현상, 사물을 정점(vertex) + 간선(edge)로 표현한 것
* G = (V, E)
* 인접하다: 두 정점이 간선으로 연결되어 있음
* 종류: 그래프, 가중치가 있는 그래프, 유향그래프(방향이 있는 그래프)

## 그래프의 표현: 인접 행렬
* N x N 행렬 (N: 정점 수)
* (i, j) = 0: i, j간 간선 존재 X, (i, j) = 1: 간선 존재 
* 유향그래프: i -> j로 연결되는 간선의 존재 여부
* 가중치가 있는 그래프: 1 대신 가중치 기재


* 간선이 연결되지 않은경우 0 대신 infinite 기재할 수 있음

### 장, 단점
* 장점: 간선의 존재여부를 즉각 알 수 있음, 밀도가 높을때 적합
* 단점: NxN 행렬 표현, sigma(n^2^)의 복잡도, 밀도가 낮을때는 공간낭비

## 그래프의 표면: 인접 리스트
* N개의 연결리스트로 표현 (N: 정점 수)
* i번째 리스트는 정점 i에 인접한 정점을 리스트로 연결
* 가중치가 있는 그래프에서는 가중치도 같이 저장

### 장, 단점
* 장점: 적은 공간 낭비, 밀도가 낮을때 적합
* 단점: 밀도가 높은경우 연결리스트 생성에 많은 비용, 연결된 노드를 순차탐색(느림)

## 그래프 순회 (Week 8-1)
* BFS: 너비우선 탐색
* DFS: 깊이우선 탐색
* 많은 경우의 수 존재 ==> 규칙만 만족하면 됨
* 결과: 그래프에서 사이클을 제외 ==> 신장트리(Spanning tree)

### 깊이우선탐색 (Depth First Search)
* 갈수 있는 한 깊이 탐색
* 수행시간: sigma(|V| + |E|)

```
DFS(G){
    for each v in V
    	visited[v] <- NO; # 초기화
    for each v in V
    	if(visited[v]=NO) then aDFS(v)
}

aDFS(v){
    visited[v] <- YES; 	# 방문함
    for each x in L(v)	# v에 인접한 정점들: x
    	if(visited[x] = NO) then aDFS(x);
}
```

### BFS (Breadth First Search)
* 수행시간: sigma(|V| + |E|)
```
# s: 출발점
BFS(G, s){
    for each v in V
    	visited[v] <- NO;	# 초기화
    visited[s] <- YES;
    enqueue(Q, s);
    
    while(Q is not empty){
        v <- dequeue(Q);
        for each v in L(v)
        	if(visited[v]=NO) then
        		visited[v] <- YES;
        		enqueue(Q, v);
    }
}
```

## Minimum Spanning Trees (최소 신장 트리)
* 조건: 무향 연결 그래프(연결그래프: 모든 정점간에 경로가 존재하는 그래프)
* 트리: 사이클이 없는 연결그래프 (n개의 정점, n-1개의 간선)
* 그래프 G의 신장트리: G의 정점, 간선으로만 구성된 트리
* G의 최소신장트리: G의 신장트리들 중 간선의 합(가중치 합)이 최소인 신장트리


* 알고리즘: Prim, Kruskal

### Prim Algorithm (Week 8-2)
* Greedy 알고리즘의 일종 (전체를 부분에서 점진적으로 확장해 전체를 계산하는 알고리즘)
* 시간복잡도: O(|E| log |V|)
* 복습!

#### 알고리즘
1. S: 공집합, d: 무한대
2. 모든 정점을 무한대로 설정
3. 시작점을 0으로 설정
4. V-S(차집합)에서 d(정점의 값)가 가장 작은 정점(u)을 추출
5. S <- S + {u}
6. u와 인접한 정점리스트에서 한점을 추출(v)
7. v: V-S에 속하고, (u, v)의 가중치 <= d[v] 일때 d[v] <- w(u, v); tree[v] <- u;
8. S != V이면 4. 로 돌아가 반복


* Version2: Q <- V 다음, Q가 공집합일때 까지 반복

### Kruskal Algorithm
* 작성중

#### 알고리즘



## Shortest Path Algorithm
* 조건: 간선 가중치가 있는 유향 그래프 (무향그래프: 양쪽으로 유향간선이 있는 그래프)
* 두 정점 사이의 최단경로: 간선의 가중치 합이 최소인 경로 (간선 가중치의 합이 음 -> X (무한루프: 돌때 마다 값이 작아짐) )


### 단일 시작점 최단경로
* `단일 시작점 -> 각 정점`의 최단경로
* 다익스트라 (음의 가중치 허용 X)
* 벨만포드 (음의 가중치 허용)
* 사이클이 없는 그래프의 최단경로

### 모든 쌍 최단경로
* 모든 정점 쌍 사이의 최단경로 모두 계산
* 플로이드 워샬

### Dijkstra Algorithm
* 시간복잡도: O( |E| log |V| )

#### 구현
1. S: 공집합, 루트를 제외한 모든 정점의 값: 무한
2. V-S중 d(정점의 값)가 가장 작은 정점(u) 추출 (extractMin(Q, d))
3. S 합집합 {u}
4. 정점 u와 인접한 정점리스트 생성 후 1개(v) 추출
5. v가 V-S에 속함 and Du > Du + Wuv이면 Dv <- Du + Wuv

### Bellman-Ford Algorithm
* 작성중

## Floyd-Warshall Algorithm (Week 9-1)
* 모든 정점들 간 최단거리 구하기

### 예시
* Road Atlas
* 네비게이션 시스템
* 네트워크 라우팅

### 구현에 필요한 정의
* 구해야 할 최단경로는 n^2개
* dm(i, j): 최대 m개의 간선을 사용해서 i->j에 이르는 최단 거리
* `m = 1`: dm(i, j) = w(i, j)
* `m >= 2`: min(dm-1(i, k) + w(k, j))

### 간단한 구현
1. `d1(i, j) <- w(i, j)` 로 초기화 (1 ~ i, j ~ n)
2. `dm(i, j) <- min{dm-1(i, k) + w(k, j)}` 수행 (2 ~ m ~ n) (1 ~ i, j ~ n) (1 ~ k ~ n)


* 수행시간 O(|V|^4^)

### 시간복잡도 개선
1. `d0(i, j) <- w(i, j)`로 초기화 (1 ~ i, j ~ n)
2. `dk(i, j) <- min{dk-1(i, j), dk-1(i, k) + dk-1(k, j)}` (1 ~ k, i, j ~ n)


* i: 시작점
* j: 마지막 정점
* k: 중간정점 집합


## 싸이클이 없는 그래프의 최단거리
* 싸이클이 없는 유향 그래프: Directed Acyclic Graph
* DAG의 최단경로: 선형시간

### 알고리즘
1. `du <- inf.` (u in V(정점))
2. `dr <- 0` r: 루트
3. G의 정점을 위상정렬
4. `if(du + w(u,y) < dv) THEN dv <- du + w(u, v)` ( u in V (위상정렬 순) ) (v: u와 인접한 정점)


* 수행시간: Sigma(|V| + |E|)
* 직접 해볼것!!!!!!!!!

## 강연결요소 (Strongly Connected Components)
* 강연결요소: 그래프의 모든 정점쌍에서 양방향으로 경로가 존재
* 강연결요소: 강하게 연결된 부분 그래프
* 임의의 그래프에서 강연결요소 찾기! (특히 유향 그래프에서)

### 알고리즘
1. 그래프에 대해 DFS수행, 각 정점 v의 완료시간 Fv를 계산 (완료시간: 더 이상 방문할 정점이 없는 순으로 넘버링 ) (출발점은 아무거나 하나 지정)
2. 모든 간선들의 방향을 뒤집어 Gr 생성
3. DFS를 Gr에 대해 수행. 단, 시작접은 1에서 구한 Fv중 가장 큰 값(=> 나머지 부분의 Fv중 가장 큰 값)
4. 단계 3에서 만들어진 분리된 트리 == 강연결요소
5. 3번 단계 반복 (남은 정점이 없을때 까지)


* P.325 페이지(???) (수업 마지막 슬라이드 3분 30초 경): 증명 (but, 큰 의미 없음, 눈으로 식별 가능)