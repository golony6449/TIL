# 동적프로그래밍

# 조약돌 놓기 문제
* 3 X N 테이블, 각 칸에 양 or 음의 정수가 기록됨
* 제약조건: 각 열에는 적어도 하나의 조약돌, 가로-세로방향으로 인접한 두칸에 동시에 놓을 수 없음
* 목표: 돌이 놓인 자리에 있는 수의 합이 최대가 되도록 하기

## 가능한 패턴
* 1개: 상(1), 중(2), 하(3)
* 2개: 상+하(4)

## 양립할 수 있는 패턴
* 앞, 뒤로 가능

### 1개: 상의 경우
* 중(2), 하(4) 가능

### 1개: 중의 경우
* 상(1), 하(3), 상+하(4) 가능

### 1개: 하의 경우
* 상(1), 중(2) 가능

### 2개: 상+하의 경우
* 중(2) 가능

## 구현: 재귀
* i열이 패턴 p로 놓일때 i열 까지의 최대 점수 합 계산 함수(pebble) 구현
* 재귀적 호출(i -> 1 까지 반복)

1. i가 p일때 i-1에서 가능한 패턴을 계산
2. pebble(i-1, 패턴) 실행
3. `return 현제 패턴 값 + 이전단계(i-1) 까지의 합`

* 최종 함수: pebble(n, 1) ~ pebble(n, 4) 중 최대값이 최종적인 답 (n열 까지 조약돌을 놓는 방법중 최대점수합)

## 구현: DP
* 요건 만족: Optimal Substructure(pebble(i, .)에 pebble(i-1, .)이 포함됨), Overlapping recursive calls(중복호출 심함)

* n열 까지의 최대합 계산 함수: pebbleSum(n)
1. 4 X n 행렬 생성
2. peb[1, p] <- w[1, p] (p: 1~4)
3. peb[i, p] <- w[i, p] + max{peb[i-1, q]} (i: 2~n) (p: 1~4) (q: p와 양립가능한 패턴)
4. `return max(peb[n, p])`

* 복잡도: O(n) = 12(n-1) + 4

