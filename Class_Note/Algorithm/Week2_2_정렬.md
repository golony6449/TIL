# 정렬
* 특정 기준에 따라 순서를 변경

## Sorting Algorithm
* nlogn ~ n^2 사이
* 입력이 특수한 성질을 만족하는 경우는 O(n) 가능

## Selection Sort
* 각 루프마다: 최대원소 탐색 -> 가장 우측 원소와 교환 -> 가장 우측 원소를 제외하고 반복(재귀적 구조도 가능)
* O(n^2)

### 구현
* 루프는 n-1번 반복
* 비교횟수: n-1 --> 1
* 교환

## Bubble Sort
* 바로 옆의 원소와 비교, 교환
* 가장 큰 수 부터 정렬

### 구현
* Selection Sort와 동일
* 단, 인접한 원소끼리 교환한다는 차이점 존재

## Insertion Sort
* 지정된 원소의 앞부분은 정렬이 되어있다고 간주, 앞부분에 '삽입' 하는 방식으로 정렬
* 0번 원소는 정렬이 되어있다고 보고, 1번(2번째 원소) 부터 시작

### 구현
* 루프는 i-1번 반복
* 최악의 경우 루프시 n-1번 비교

* Worst Case: 모두와 비교 (n-1번 비교)
* Average Case: (0.5) * Worst Case

### 제귀적 정의와 연관성
* A[0]는 정렬되어있음
* A[0 ~ K]까지 정렬 되어있다면, 적절한 위치에 삽입을 통해 A[0 ~ K+1]까지 정렬 됨
* 수학적 귀납법과 유사

## Merge Sort
* 정렬할 데이터를 쪼개서 Sort한 뒤, <b> Merge</b>해 정렬
* 원소가 1개가 남을때 까지 나눈 뒤, 정렬, 합병(Merge)
* O(nlogn)
* 이진 트리형태의 경우 보통 O(nlogn)

### Merge 단계
* 각각의 정렬된 리스트의 가장 앞에 존재하는 2개의 원소를 비교, 작은 값을 앞으로 이동
* 한 개의 리스트가 모두 소진된 경우, 결과의 마지막에 순서대로 저장

## Quick Sort
* 분할한다는 점에서는 Merge Sort와 유사, 기준이 되는 중간을 정하는 위치가 다름 (아무 데이터나 선택)
* 기준에서 좌측은 기준보다 작은 값, 우측은 기준보다 큰 값이 되도록 정렬
* Average: O(nlogn)
* Worst Case: 정한기준값에서 정렬했을때, 좌측(우측)으로 배치가 몰리는 경우 효율 낮음 (O(n^2))

### 구현
1. 0번 원소를 선택 가운데로 이동 (상황에 따라 기준 인덱스 변경 가능)
2. 조건을 만족하도록 재배치(정렬) (기준보다 작은 값은 앞에서 부터, 큰 값은 뒤부터 채우면 자리이동 횟수를 줄일 수 있음)
3. 기준의 좌, 우측을 재귀적 반복

* 자리이동 횟수를 줄이는 것이 중요

* Week2 Session 3 Slide 5 참고
* P.26 ~ 29

## Heap Sort
* Heap: 각 노드의 값을 자신의 child 보다 크지 않은 완전 이진 트리
* 배열을 Heap으로 만든 뒤, 차례로 힙에서 제거해 정렬
* Heap을 만드는 과정에서 시간 소요 큼

### 구현
1. 루트 제거
2. 완전이진트리 구성을 위해 가장 마지막 뭔소를 루트에 위치
3. Heap 구성을 위해 재구성(Heapify)

## O(n) Sort
* 두 원소를 비교하는 것이 기본연산인 정렬의 하한선은 omega(nlogn)
* 특수한 경우 O(n)도 가능
* Counting Sort (계수 정렬): 원소가 모두 일정 범위(-O(n) ~ O(n))내에 존재
* Radix Sort (기수 정렬): 자리수가 지정된 경우

### Radix Sort (기수 정렬)
* j번째 정수를 이용해 Stable Sort 수행
* j: 가장 우측 숫자(d번째 원소) -> 좌측 숫자 (1번째 원소) 

* Stable Sort: 같은 값을 가진 Item이 sort 후에도 원래의 순서가 유지되는 성질을 가진 Sort

### Counting Sort (계수 정렬)
1. 정렬할 리스트에 존재하는 <b>숫자의 갯수</b>를 길이로 하고 모든 원소가 0인 배열 생성
2. 각 숫자에 해당하는 새로운 배열의 원소에 1을 더함 (Counting)
3. 원소가 가리키는 값을 원소의 값만큼 출력

* 데이터가 단순한, 한정된 상황에 한해서 사용 가능

## 효율성 비교
* Selection, Bubble, Insertion: n^2
* Merge, Quick, Heap: nlogn (단 Quick은 Worst Case에서 n^2)
* Counting, Radix: n (단, 한정된 상황에 한해서 사용 가능)

