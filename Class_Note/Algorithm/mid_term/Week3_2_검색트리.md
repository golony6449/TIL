# 검색트리

## 개요
* 데이터 삽입, 삭제시 데이터 이동을 최소하하는 것이 중요

## 용어
* record: 개체에 대해 <b>수집된 모든 정보</b>를 포함하는 저장 단위
* field: 레코드에서 각각의 정보
* Key: 다른 노드와 구분할수 있는 요소, 레코드를 대표할 수 있는 부분, 단일필드 - 다중필드 모두 가능
* search tree: 각 노드가 규칙에 맞도록 하나씩의 키를 보유 ==> 해당 레코드 위치 파악 가능

## Binary Search Tree
* 하나의 키 소유
* 최상위 루트노드 + 각 노드는 최대 2개의 자식 보유
* <b>왼쪽 자식 노드의 키 값 < 부모의 키 값 < 오른쪽 자식의 키 값</b>

### BST에서의 검색
1. 루트의 키값과 비교, 같은 경우 반환
2. 루트의 키 값보다 target이 작은경우 왼쪽 자식의 키값과 비교, 큰 경우 오른쪽 키 값과 비교
3. 반복 (하위 노드가 없을때 까지)

* 트리의 서브트리는 결국 트리임

### BST에서의 삽입
1. NULL 노드 여부 확인, NULL인 경우 삽입
2. 루트의 값과 비교, 작으면 좌측, 크면 우측 노드로 이동

### BST에서의 삭제
0. Target이 루트인지 확인
* 경우에 따라 다르게 처리
1. target이 Leap ==> 삭제
2. target의 자식노드가 1개 ==> Target의 자식을 Target의 부모에 연결
3. target의 자식노드가 2개 ==> !!!

### Target의 자식노드가 2개인 경우
* 우측 서브트리의 최소원소를 Target 위치로 이동 ==> 노드간 부등호 관계 유지를 위함
* 최소원소의 자식이 있는 경우, 삭제 알고리즘 전체를 재귀적으로 처리

#### 삭제 알고리즘
* Slide 17 복습

## Red-Black Tree
* BST에서 Depth의 불균형에 따른 비효율성 해소
* 노드에 블랙 or 레드로 색을 칠하되 특정조건을 만족
* 모든 NULL 포인터는 NULL이라는 Leap 노드를 가리킨다고 가정 ==> 포화이진트리

1. 루트는 블랙
2. 모든 Leap는 블랙
3. 노드가 레드 --> 해당 노드의 자식은 블랙
4. 루트 -> 리프 까지의 경로에서 만나는 블랙노드의 수는 동일

### RBT에서의 삽입
* BST의 경우와 동일
* but 삽입된 노드를 Red로 색칠
* 문제: 삽입위치의 부모노드(p)가 Red? ==> 부모의 형제 노드(s) 색상에 따라 결정

* s가 Red: p, s를 블랙, p^2을 Red로 지정, P^2에서 같은 문제 발생시 재귀적으로 해결

* s-블랙, 

* 반드시 복습!!!

### RBT에서의 삭제
* 자식이 없음 or 1개인 경우만 고려해도 무관
* 삭제노드-Red: 문제 X
* 삭제노드-Black, 자식-Red: 문제 X

#### 문제가 되는 상황
* Black 노드가 연속되는 경우: 4번 특성 위반 ==> 삭제 대상 형제 상황에 따라 처리 방법 다름
* Black 노드가 모자라는 노드에 -1 표기 ==> 이를 해결하도록 재배치

#### Black 수가 부족한 노드(x)의 부모가 Red
* 3가지

#### Black 수가 부족한 노드(x)의 부모가 Black
* 4가지

#### 케이스 병합 ==> 총 5개의 경우
