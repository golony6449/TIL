# 검색트리

## B-Tree
* 균형잡힌 다진검색트리
* 디스크 접근 횟수를 최소화 => 트리의 높이를 최소화 하는 것이 유리함
* 다진 검색트리가 균형을 유지하도록 해 Worst Case의 접근횟수 최소화

### 구성
* 루트를 제외한 노드는 k/2 ~ k개의 키를 가짐
* 모든 리프 노드는 같은 깊이

### 접근
| 자식링크 | 키, 페이지 | 자식링크 | 키, 페이지 |자식 링크 | 키, 페이지 | ...... |
* 매칭되는 키의 페이지에 접근
* 페이지에 존재하는 많은 레코드 중 필요한 레코드에 접근
* 낭비되는 레코드 존재 => 디스크의 읽기 단위는 페이지 == 속도 동일

### 삽입
1. 키 위치 탐색
2. 해당위치 삽입
3. 최소 키 갯수 ~ 최대 키 갯수 범위 초과시 합병, 분할 수행

* if 인접한 페이지의 키 갯수에 여유가 있는 경우: 인접한 페이지로 넘김
* else: 가운데 키를 부모 노드로 이동시키고, 분할 실시

#### 분할했을때, 부모가 오버플로우?
* 부모를 가운데 키값을 부모로 하도록 해 분할

### 삭제
* Underflow 문제!

### 삭제 대상이 Leap인 경우
* 해당 키 삭제

### 삭제대상이 Leap가 아닌 경우
1. 자식 노드(페이지)와 교환
2. Leap 삭제
3. Underflow 확인

* Underflow 발생시, 인접한 노드(페이지)에서 키를 가져온 뒤, 부모와 관계 재정립

#### 인접한 페이지에서 가져올 키가 없다!
1. 인접한 페이지와 병합
2. 부모의 Underflow 확인
3. 반복

* 병합은 해당 레벨의 노드의 상위로만 영향 (자식 아래의 레벨에는 영향 X)


## 다차원 검색
* 검색키가 두개 이상의 필드로 이루어진 검색

## KD-Tree
* K Demention Tree
* 한 레벨에서 하나의 필드 사용 
* => k개의 필드를 사용하는 검색이면, K개의 레벨을 내려갔을때, 검색 대상 필드 위치
* ==> 한 노드(레코드)는 K개의 필드로 구성
* 깊이 > K인 경우 1번필드 ~ K번 필드까지 비교 후, 다시 1번 필드 부터 비교
* 값이 동일한 경우 좌측, 우측 무관(단, 일관성 있게)

### 나눈다는 것의 의미
* 공간을 분할해가면서 검색, 삽입 등 수행

### 검색, 삽입
* 일반적인 트리와 동일

### 삭제 (대상: r)
* 자식이 없는 경우: r 제거
* 자식이 하나 뿐: 자식이 둘인 경우와 동일 취급
* 자식이 둘: 우측 서브트리 중, r에서 분기에 사용한 필드 값이 가장 작은 노드 삭제 후 r의 자리로 이동 (재귀)
* Slide 24, 28 참고 (4주차 1번 강의)

* 최소 값 찾기: 같은 필드를 비교하는 레벨의 좌측 서브트리만 고려하면 됨 (Slide 28)

## KDB-Tree
* KD-Tree + B-Tree = 다차원 키를 사용할 수 있도록 B-Tree를 확장 
* 내부 노드 1개는 K차원 공간에서 한 영역을 담당
* 루트 노드는 K차원 공간 전체 커버
* 같은 레벨에 있는 모든 노드는 곂치는 영역이 없고, 합치면 K차원 전체의 공간이 됨
* 각각의 차원은 1개의 블록(디스크 페이지)


## R-Tree
* B-Tree의 다차원 확장(= 여러개의 키)
* 모든 레코드는 리프 노드에서만 가리킴
* 다차원 도형 저장 가능
* 
* R-Tree에서는 영역이 곂칠 가능성 존재 ==> 곂치는 레코드의 경우 공통되는 영역 모두를 참조해야 할 수도 있음

### 삽입
* 공간이 비어있는 경우 삽입하면 끝
* 공간이 비어있지 않은 경우 기존영역 재분배
* 직사각형으로 재분배 ==> 노드를 주고받는 B-Tree와의 차이점

## Grid File
* 검색트리 X
* 키의 내용에 의해 한번에 저장, 검색을 할 수 있는 다차원 파일
* 영역 분할

### 삽입
* 키 갯수의 한계를 넘지않는 선에서 삽입
* 넘는 경우 영역분할 수행
* 경계를 테이블로 관리 (경계선에 대한 정보 보유) (Slide 18번 참고)