# Chapter 10 문자열 매칭
## 문자열 매칭 (Week 9-3)
* 입력: 텍스트문자열, 패턴문자열
* 수행작업: 텍스트 문자열이 패턴문자열을 포함하는지 확인

## 원시적인 매칭
* P: 패턴(길이: m), A: 대상 (길이: n)
* P[1...m]이 A[i...i+m-1]이면 i자리에서 매칭 (앞 글자부터 매칭 확인: m번)
* A 전체를 순회 (n번)


* 수행시간: O(m * n)

### 비효율적인 예
* 같은 키워드가 반복된다면 다음 반복 시점까지 이동해도 무관 but, 1칸씩 이동하면서 비교 
* ==> 비효율적
* 슬라이드 6 참고

## 오토마타를 이용한 매칭
* 매칭이 진행된 상태들간의 관계를 오토마타로 표현


* 오토마타: 문제해결 절차를 상태의 전이로 표현한 것
* 구성요소: Q, q0, A, sigma, delta
* Q: 상태집합
* q0: 시작상태
* A: 목표 상태들의 집합
* sigma: 입력알파벳
* delta: 상태전이함수

### 구현
* 2D Array를 이용해 구현
* 특정 단계에 특정 문자열 매칭시 이동할 단계를 표기

### 알고리즘
* A: 입력 문자열, delta: 상태 변화 함수, f: 마지막 상태, n: 문자열 길이
* q: 현재단계

1. `q <- 0`
2. `q <- delta(q, A[i])`: 모든 문자열에 대해 비교
3. `if q=f THEN 매칭발생`
4. i 증가 후(= 다음글자 이동) 2 ~ 3번 단계 반복

* 수행시간: Sigma(n + |SUM(m)|)

## 라빈-카프 알고리즘 (Rabin-Karp)
* 문자열 패턴을 수치로 변경, 문자열 비교 ==> 수치비교로 대신
* <b>한번에 패턴문자열 - 타켓문자열을 비교할 수 있음</b>
* 수치화: 가능한 문자집합 크기에 따라 진수 결정

### 수치화 예시
* 문자집합(sigma) = {a, b, c, d, e}
* 크기: |sigma| = 5
* ==> a, b, c, d, e ==> 0, 1, 2, 3, 4에 매칭
* 문자열 cad ==> 2* 5^2^ + 0 * 5^2^ + 3 * 5^0^ = 28

### 수치화 작업의 부담
* A[]에 대응되는 수치 계산 ==> 한 문자당 Sigma(m)의 시간 소요 ==> 전체는 Sigma(m * n)
* 원시적인 매칭에 비해 나은게 없다는게 함정


* 다행히, m의 크기(타겟 문자열 크기)에 무관하게 계산가능 
* `ai = d(ai-1 - dm-1 * A[i-1]) + A[i+m-1]`
* `dm-1`은 반복사용됨 ==> 미리 한번만 계산해서 사용
* 곱셉 2번, 덧셈 2번으로 계산가능
* 슬라이드 12 복습!