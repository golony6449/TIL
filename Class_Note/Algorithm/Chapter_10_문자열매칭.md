# Chapter 10 문자열 매칭
## 문자열 매칭 (Week 9-3)
* 입력: 텍스트문자열, 패턴문자열
* 수행작업: 텍스트 문자열이 패턴문자열을 포함하는지 확인

## 원시적인 매칭
* P: 패턴(길이: m), A: 대상 (길이: n)
* P[1...m]이 A[i...i+m-1]이면 i자리에서 매칭 (앞 글자부터 매칭 확인: m번)
* A 전체를 순회 (n번)


* 수행시간: O(m * n)

### 비효율적인 예
* 같은 키워드가 반복된다면 다음 반복 시점까지 이동해도 무관 but, 1칸씩 이동하면서 비교 
* ==> 비효율적
* 슬라이드 6 참고

## 오토마타를 이용한 매칭
* 매칭이 진행된 상태들간의 관계를 오토마타로 표현


* 오토마타: 문제해결 절차를 상태의 전이로 표현한 것
* 구성요소: Q, q0, A, sigma, delta
* Q: 상태집합
* q0: 시작상태
* A: 목표 상태들의 집합
* sigma: 입력알파벳
* delta: 상태전이함수

### 구현
* 2D Array를 이용해 구현
* 특정 단계에 특정 문자열 매칭시 이동할 단계를 표기

### 알고리즘
* A: 입력 문자열, delta: 상태 변화 함수, f: 마지막 상태, n: 문자열 길이
* q: 현재단계

1. `q <- 0`
2. `q <- delta(q, A[i])`: 모든 문자열에 대해 비교
3. `if q=f THEN 매칭발생`
4. i 증가 후(= 다음글자 이동) 2 ~ 3번 단계 반복

* 수행시간: Sigma(n + |SUM(m)|)

## 라빈-카프 알고리즘 (Rabin-Karp)
* 문자열 패턴을 수치로 변경, 문자열 비교 ==> 수치비교로 대신
* <b>한번에 패턴문자열 - 타켓문자열을 비교할 수 있음</b>
* 수치화: 가능한 문자집합 크기에 따라 진수 결정

### 수치화 예시
* 문자집합(sigma) = {a, b, c, d, e}
* 크기: |sigma| = 5
* ==> a, b, c, d, e ==> 0, 1, 2, 3, 4에 매칭
* 문자열 cad ==> 2* 5^2^ + 0 * 5^2^ + 3 * 5^0^ = 28

### 수치화 작업의 부담
* A[]에 대응되는 수치 계산 ==> 한 문자당 Sigma(m)의 시간 소요 ==> 전체는 Sigma(m * n)
* 원시적인 매칭에 비해 나은게 없다는게 함정


* 다행히, m의 크기(타겟 문자열 크기)에 무관하게 계산가능 
* `ai = d(ai-1 - dm-1 * A[i-1]) + A[i+m-1]`
* `dm-1`은 반복사용됨 ==> 미리 한번만 계산해서 사용
* 곱셉 2번, 덧셈 2번으로 계산가능
* 슬라이드 12 복습!

### 알고리즘
* A: 대상 문자열
* P: 패턴
* d: A의 도메인 수

```
A: abcde
P: cd
basicRabinKarp(A, P, d){
    // n: 배열 A의 길이, m: 배열 P의 길이
    p <- 0, a1 <- 0;
    for i <- 1 to m{
        p <- d*p+P[i]		// 'cd'를 정수로 변경한 값
        a1 <- d*a1 + A[i]	// A의 첫 두글자('ab')를 정수로 변경
    }
    
    for i <- 1 to n-m+1 {
        if (i!=1) THEN ai <- d*(ai-1 - d(m-1)A[i-1]) + A[i+m-1]
        if (p=ai) THEN A[i] 자리에서 매칭되었음을 알림
    }
}
```

#### 문제점
* 문자집합의 합, m의 크기에 따라 ai가 매우 커질수 있음 (심한경우 오버플로우 발생 ==> 나눠서 연산해야함)
* Solution: 나머지연산을 이용, ai의 크기 제한
* ==> ai = d(ai-1 - dm-1*A[i=1]) + A[i+m-1] 대신
* ==> bi = (d(b(i-1) - (d(m-1) mod q) * A[i-1]) + A[i+m-1]) mod q 사용
* q: 충분히 큰 소수, d*q가 레지스터에 수용될수 있어야 함
* 슬라이드 3 해보기!!

### 나머지를 이용한 알고리즘
* 문제점: 값이 같다는 보장 불가능 (18%3 == 12%3)
* Solution: 매칭시, 실제로 같은지 문자단위 비교
* q가 크면 클수록 문자열이 다를 가능성 자체는 낮아짐, 그래도 확인할 필요 있음


## Knuth-Morris-Pratt 알고리즘
* 오토마타를 이용한 매칭과 유사한 동기 (매칭에 실패했을때 돌아갈 상태 준비)
* 차이점: 오토마타 대비, 준비작업이 단순
* 준비작업: 매칭 실패시, 비교 문자열에서 중복되는 부분이 있다면, 여러칸을 건너 뛸 위치 파악, 준비

### 매칭 실패시, 돌아갈 곳 준비 작업
* P[] = 'abcdabcwz'
* 상황: w에서 미스매칭
* 실패한 문자를 P[4]부터 비교 시작 (인덱스 시작번호: 1)
* <b>PI 배열에 실패시 돌아갈 인덱스 저장</b>

### 알고리즘
1. 전처리(PI 배열 작성) 수행
2. i = 1 (본문 문자열 포인터), j = 1 (패턴 문자열 포인터)
3. IF (j = 0 or A[i] = P[i]) THEN i++; j++		(문자열 매칭)
4. ELSE j = PI[j]						(문자열 미스매칭 -> i변경 없이 비교할 인덱스만 변경)
5. IF (j = m+1) THEN A[i-m] 에서 매칭됨을 출력, j = PI[j]
6. i <= n인 동안 반복


* 수행시간: O(n)

#### 전처리
1. j = 1, k = 0, PI[1] = 0 (시작 인덱스: 1)
2. IF k==0 or P[j] = P[k] THEN j++, k++, PI[j]=k
3. ELSE k = PI[k]
4. j <= m인 동안 반복 (m: 패턴의 길이)

## Boyer-Moore 알고리즘
* 앞선 알고리즘과의 공통점: 텍스스틔 문자열을 적어도 한번은 확인, 최선의 경우에도 Sigma(n)
* 차이점: 텍스트 문자를 다 보지 않아도 됨 (패턴의 오른쪽 부터 비교) 
* => 비교할 필요가 없는 경우에는 하지 않고 넘어감

### Motivation
1. 비교대상과 패턴의 한 문자를 비교
2. 불일치 발생
3. 패턴에 비교대상 문자열이 존재하지 않음 ==> 패턴이 대상 문자열을 통째로 넘어가도 무관
4. 패턴에 비교대상 문자열이 존재 ==> 패턴의 문자열과 비교대상 문자열의 위치를 일치시킴 (Week 10 슬라이드 3 참고)

### 점프 정보의 준비
* `문자 - 매칭 실패시에 점프할 인덱스`를 쌍으로 저장
* 매칭에 실패시 해당 인덱스 만큼 이동
* 패턴에 동일한 문자열 존재시, 둘 중 점프할 인덱스가 큰 순서쌍을 무시

### 원시 - 개선된 알고리즘의 비교
* 원시 알고리즘: <b>한 문자씩 이동하면서</b> 모든 문자열을 비교
* 개선된 알고리즘: <b>점프 테이블에 존재하는 값 만큼을 이동하면서</b> 모든 문자열을 비교
* i <= n - m + 1 인 동안 반복

### 보이어 무어 호스풀 알고리즘
* n: 배열 A의 길이
* m: 배열 P의 길이

```
BoyerMooreHorspool(A[], P[]){
    computeSkip(P, jump)
    i <- 1;
    while(i <= n-m+1){
        j <- m; k <- i+m-1;
        while(j > 0 and P[j] = A[j]){
            j--; k--; // 비교대상 문자열 중 가장 뒷 문자부터 비교
        }
        if (j = 0) THEN A[i] 자리에서 매칭됨을 알림
        i <- i + jump[A[i+m-1]];
    }
}
```

### 휴리스틱의 적용
* 불일치 문자 휴리스틱: 불일치한 문자를 Jump 테이블에서 탐색, 해당 값 만큼 이동
* 일치 접미부 휴리스틱: 일치한 접미부가 패턴안에 존재하는 경우 다음 일치부분으로 이동
* 더 많이 Jump 하는것이 유리