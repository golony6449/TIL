# 동적프로그래밍

* 재귀함수: 이해 용이, 느린 속도
* 반복문: 빠른 속도, 적은 메모리 사용

## 베경
### 재귀적 해법
* 큰 문제에 닮은 꼴의 작은 문제가 포함되어 있음
* 관계 중심 파악 => 문제의 간소화 가능
* 심한 중복호출의 가능성 존재

#### 바람직한 예
* 퀵정렬, 병합정렬
* factorial
* 그래프에서 DES

#### 나쁜 예
* 피보나치
* 행렬곱셈의 최적곱

## 피보나치 수 계산
* f(n) = f(n-1) + f(n-2)
* f(0) = 1
* f(1) = 1

### f(5) 계산을 위해 재귀적 방법을도입
* f(3), f(4) 계산 필요 ==> f(2) 2번 계산할 필요 있음
* 중복계산 발생
* 심지어 상위 레벨로 갈수록 더 많은 중복계산 발생

### 피보나치 수열의 Call Tree
* 재귀적으로 호출되는 함수를 트리형태로 표현

### DP 알고리즘을 이용한 피보나치수
* 루트 부터 계산 X
* 가장 깊은 깊이 부터 계산 시작
```
fibonacci(n){
    f[1] <- f[2] <- 1;
    for i <-3 to n
    	f[i] <- f[i-1] + f[i-2];
    return f[n];
}
```

## DP의 적용 요건
* Optimal sub-structure: 큰 문제의 최적솔루션에 작은 문제의 최적솔루션 포함
* Overlapping recursive call: 재귀적 방법으로 해결시, 재귀호출 중복이 심각

## 문제 1. 행렬 경로 문제
* 양 or 음의 정수로 구성된 nXn 행렬, 좌상단 -> 우하단 까지 이동
* 이동방법: 오른쪽 or 아래쪽만 이동 가능
* 목표: 좌상단 -> 우하단 이동, 칸 수에 있는 값들을 합한 값이 최소가 되도록 할것

### 재귀 알고리즘
* 도착점에서 출발점(1, 1)을 추종
* (1, 1)에 도착할때 까지 함수를 재귀적으로 호출
* `i != 1`, `j != 1`인 경우 => x, y축 감소를 모두 계산후 작은 값 사용 ==> 중복 발생

### DP를 이용한 알고리즘
* 동일한 크기의 매트릭스를 하나 더 생성, 시작점(1, 1) 부터 해당 좌표까지의 최소 누적값 기재
* 시작점부터 종점을 추종
* 시간복잡도: O(n^2^)

1. (1, 1)은 그대로 기재
2. 1행과, 1열의 경우는 합을 기재
3. 나머지는 우측, 좌측 원소중 작은 값을 가져와 해당 위치 값과 덧셈 연산