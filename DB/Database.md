# Database
### based on 만화로 쉽게 배우는 데이터베이스, 컴퓨터시스템개론
=================================

## 기존의 방식 - 파일시스템
* 각각의 프로그램(부서)에서 데이터를 파일형태로 따로따로 저장
* 프로그램과 파일은 1:1로 매칭됨

### 파일시스템의 문제점
* 데이터중복 -> 리소스 낭비, 공통되는 데이터 변경시 오류 가능성 있음
* 데이터가 분산되어 있음 -> 기존의 데이터를 그대로 재사용 불가능 -> 별도의 파일 추가 생성 (프로그램-파일은 1:1) -> 문제점 심화

#### 문제점 해결을 위해 Database 도입!

## Database
* 가지고 있는 데이터를 여러 사람들이 사용하기 위함

### 요구사항
* 간단한 데이터 입출력 방법 제공
* 안정성 확보 (기밀성, 장애 대비)
* 동시에 일어나는 동일데이터의 수정 상황 대비
* 신속성 (속도)

### DBMS
* DataBase Management System
* 사용자(프로그램) - DB 사이에 존재, 요구사항 충족

### 기본용어
* Recode(레코드): 데이터의 기본 단위, 행렬에서의 행
* Field(필드): 레코드 안 각각의 항목, 행렬에서의 열, 자료의 속성 결정(자료형, 길이, NULL값 가능 여부 등)
* 유일성을 가진다: 값이 중복되지 않는 필드값, 해당 값을 통해 레코드를 구분 할 수 있음 
* NULL: 공란, 값이 비어있음

### 데이터베이스 모델
* 계층형 데이터 모델(Hierarchical Data Model): 데이터들이 계층관계(Tree)를 이루고 있는 모델 (하위데이터들이 <br>1개의</br>상위데이터에 연결됨)
* 그물형 데이터 모델(Network Data ModeL): 데이터들이 그물처럼 서로서로 연결되어 있는 모델 (하위데이터들이 <br>여러개의</br>상위데이터에 연결됨)
* 관계형 데이터 모델(Relational Data Model): 데이터들이 표(Table=Relation) 형태로 구성되어 있는 모델, <br>나머지 2개 모델은 현재 사용하지 않음</br>

### 관계형 데이터베이스
* 표 형태 기반 데이터베이스
* 행: 레코드, 열: 필드
* 키(key): 필드에 부여된 역할
* 기본키(primary key): 레코드에 있어서 중요한 역할을 하는 필드(ex: 유일성을 가짐 or etc)
* 외래키(foreign key): 다른 테이블의 기본키를 참조(reference)하는 필드(열)

#### 장점
* 표를 기반으로 함 -> 쉽게 익숙해질 수 있음
* 연산을 조합해 DB에 대한 다양한 조작 수행 가능

#### RDB의 연산
* 수학에서 사용되는 개념 도입 - 일반 집합 연산자
* 합집합(union): 2개의 표(테이블)에 포함된 행을 전부 출력(세로방향), 동일한 레코드의 경우 1번만 출력
* 차집합(difference): 둘 중 1개의 표에만 있는 레코드 출력(기준표에 따라 결과 달라짐)
* 교집합(intersection): 공통으로 존재하는 레코드만 출력
* 곱집합(cartesian product): 2개의 표에 있는 행들을 조합한 모든 경우의 수

* DB 고유의 연산 - 순수 관계 연산자
* 프로젝션(projection): 특정 열을 출력
* 셀렉션(selection): 특정 행을 출력
* 조인(join): 2개의 테이블을 이어주는 기능, 이때 각 테이블의 기본키(primary key)를 참조(reference)해 적절한 레코드와 연결. (ex: A.join(B)일 때, B의 기본키를 참조하는 A의 필드(열)를 외래키(foreign key)라고 함)
* 디비전(division): 나뉨을 당하는 표에서 나누는 역할의 표의 행을 포함하는 모든 행을 추출 -> 추출한 행에서 나누는 역할의 표에 있는 모든 행을 지우는 연산, 나뉨당하는 표 - 나누는 표의 공통점 중, 나누는 표에 없는 내용을 추출

## DB 설계
* 현재의 데이터를 일정한 모델로 만들어 분석

### E-R 모델 (Entity - Relationship 모델)
* 현실 세계를 `Entity(개체)`와 `Relationship(관계)` 개념을 사용해 DB로 표현
* 주의) 개체를 바라보는 관점에 따라 관계가 달라질 수 있음
* ex) 1개의 강의는 1명의 강사가 담당 but, 1명의 교사는 여러개의 강의를 담당할 수 있음

#### 용어
* 개체: 현실에서 인식가능한 모든 것 (ex: 과일, 수출처)
* 관계: 개체간의 연결을 의미 (ex: 판매(과일과 수출처는 파는 행위로서 연결됨))
* `1:1`: 1개의 개체가 1개의 다른 개체와 연결된 상태(ex: 사과를 미국으로만 수출(사과: 미국(단일국가))
* `다:다`: 다수의 개체가 다수의 개체와 연결된 상태(ex:많은 종류의 과일을 파는 국가(다수의 과일: 다수의 판매국))
* `1:다`: 1개의 개체가 다수의 개체와 연결된 상태(ex: 앵두만 파는 국가(앵두:다수의 판매국))
* <br>정규화: 한개의 표에 1개의 행 항에 일치하지 않는 정보가 없도록, 이를 2개(다수)의 표로 나누는 작업을 의미</br>

#### 정규화 과정 예시
* 매출보고서 표의 필드:  보고서번호, 일자, 수출처코드, 수출처명, 상품코드, 상품명, 단가, 수량
* 이때 1개의 보고서 번호에 여러개의 상품코드가 연결되어 있음 (한번 수출할때 여러개의 상품을 수출하기 때문)
* 이러한 표를 `비정규형`이라고 함

##### 1차 정규화
* 이를 수출표(보고서코드,일자, 수출처코드, 수출처명), 메출명세표(보고서코드, 상품코드, 상품명, 단가, 수량) 과 같이 2개로 나눔 -> `1차 정규형`
* 이때 보고서 코드는 2개의 표의 관계를 알기 위해서 중복시킴

##### 2차정규화
* <br> 2차정규형: 기본키의 값이 정해지면 다른 열의 값도 정해지도록(함수종속성) 나눠진 표를 의미</br> -> 수출표는 이미 2차정규형(기본키: 보고서 코드)
* 즉, 기본키를 정하는 과정
* 함수종속성: 특정열의 값에 의해 다른 열의 값이 정해지는 특성

* 테이블의 필드는 기본적으로 NULL값을 가질 수 없음 -> 매출이 없는 상품은 매출명세표에 추가 불가능 (보고서 코드, 수량 값이 없음)
* 이는 매출명세표에 2개의 개체(상품, 매출)에 대한 데이터가 섞여 있음을 의미
* 매출명세표를 상품표(상품코드, 상품명, 단가), 매출명세표(보고서코드, 상품코드, 수량)로 나눔 -> `2차 정규형`
* 이때 상품표의 기본키는 상품코드, 매출명세표의 기본키는 보고서코드 + 상품코드가 됨

##### 3차 정규화
* <br>3차 정규형: 기본키 이외의 것들로 인해 다른 열들이 정해지는 일(이행종속)이 없도록 나눠진 표</br>
* 즉, 각 항목이 기본키 이외의 항목에 의해 정해지는 경우가 없도록 함
* 이행종속: 특정열의 값에 의해 간접적으로 다른 열의 값이 정해지는 특성

* 수출표의 경우 수출처를 관리 할 수 없음(수출 이력이 없는 국가는 추가 불가능)
* 즉, 수출표의 기본키 정해짐(보고서코드) -> 수출처코드 정해짐 -> 수출처명 정해짐 => 간접적으로 수출처 명이 정해지는 상황

* 수출표 -> 매출표(보고서코드, 일자, 수출처코드), 수출처(수출처코드, 수출처명)으로 나눔 -> `3차 정규형`

#### 1개의 표를 4개의 표로 나눔 but, 각각의 표는 데이터들간의 <br>관계</br>를 나타냄 -> 관계형 데이터베이스
* 외래키: 다른표의 기본키를 참조하고 있는 열을 의미(매출표: 수출처코드 매출명세표: 보고서코드, 상품코드)

### 데이터베이스의 설계
* 개념스키마: 현실세계를 모델링 하는 단계. DB의 논리적인 구조 결정 (ex: E-R모델)
* 내부스키마: 컴퓨터 내부에서 바라본 DB. DB의 물리적인 구조 결정 (ex: DB의 빠른 검색방법 설계)
* 외부스키마: 유저 어플리케이션 입장에서 본 DB. (ex: 어플리케이션을 필요로 하는 데이터 설계)

## SQL
* RDB를 조작할때 사용되는 언어
* 1개의 요청(대화)을 문 이라고 함

### 기능
* 표 작성 - 데이터 정의어 (Data Definition Language)
* 데이터 입출력(검색, 변경 포함) - 데이터 조작어 (Data Manipulation Language)
* 유저 관리(접근제어 등) - 데이터 제어어 (Data Control Language)

### SELECT - 가장 기본적인 쿼리문
* SELECT 필드명 FROM 테이블 [WHERE 조건 LIKE %두 ORDER BY 행];
* ex: SELECT 상품명 FROM 상품 WHERE 단가>=200;
* 모든 열을 요청할때는 와일드카드(*) 사용
* LIKE: 패턴지정
* ORDER BY: 지정된 행 기준으로 오름차순 정렬
* BETWEEN: 범위 지정
* GROUP BY: 그룹화

#### WHERE - 조건
* A=B: A와 B가 같다
* A>B, (A>=B): A가 B보다 크다(크거나 같다).
* A<>B: A, B가 다르다.
* 조건A AND 조건B: A와 B 둘다 참일때
* 조건A OR 조건B: A, B 중 하나 이상이 참일때
* NOT (조건): 해당 조건의 부정
* IN (): ()안의 값이 일치하는 행과 매칭 

#### LIKE - 패턴을 사용하는 조건
* %: 임의의 수의 문자와 일치
* _: 문자 1개와 일치
* ex: WHERE 이름 LIKE '%수' -> 수로 끝나는 이름 검색

#### BETWEEN - 범위지정
* ex: WHERE 단가 BETWEEN 150 AND 200

#### IS NULL
* 널값 여부를 확인하는 조건
* ex: WHERE 단가 IS NULL

### 통계함수
* ex: SELECT AVG(단가) FROM 상품 -> 상품 테이블에서 모든 단가의 평균값 출력

#### 종류
1. COUNT(*): 행의 갯수
2. COUNT(열의 이름): NULL을 제외한 행의 수
3. COUNT(DISTINCT 열의 이름): NULL, 중복된 값을 제외한 행의 수
4. SUM(열의 이름): 모든 행에서 해당 열의 값 합계
5. AVG(열의 이름): 모든 행에서 해당 열의 평균
6. MAX(열의 이름): 모든 행에서 해당 열의 최대값
7. MIN(열의 이름): 모든 행에서 해당 열의 최솟값

#### GROUP BY - 그룹화
* ex: SELECT 지방 AVG(단가) FROM 상품 GROUP BY 지방; -> 상품 테이블에서 '지방'행을 그룹화해 단가 평균을 표시

##### HAVING: 그룹화를 시켜 집계한 값에 대해 한번더 조건을 지정할 때 사용
* ex: SELECT 지방, AVG(단가) FROM 상품 GROUP BY 지방 HAVING AVG(단가)>=200G; -> '지방'행을 그룹화해 얻은 지방별 평균단가값이 200보다 큰 지방명, 평균단가를 출력

### 서브쿼리(subquery)
* 쿼리 도중 별도의 질의 수행
* SELECT * FROM 상품 WHERE 상품코드 IN (SELECT 상품코드 FROM 매출명세 WHERE 수량>=1000); -> 메출 명세표에서 수량이 1000개 이상인 상품코드와 매칭되는 상품테이블의 상품코드 레코드를 출력
* 안쪽쿼리의 결과 -> 바깥 쿼리에 전달

#### 상관관계 서브쿼리 (correlated subquery)
* 서브쿼리의 바깥에서 지정한 표를 안쪽에서 사용하는 것
* ex: SELECT * FROM 메출명세 U WHERE 수량>(SELECT AVG(수량) FROM 매출명세 WHERE 상품코드=U.상품코드);
* 바깥 쿼리의 결과에 U라는 별칭을 붙혀 <br>한 행씩</br> 안쪽쿼리에 전달 -> 안쪽쿼리의 값(수량의 평균값)을 바깥의 조건(WHERE)에 전달 -> 반복
* 즉, 상품별로 매출수량이 평균보다 큰 경우 출력

### join
* 정규화를 통해 나눠진 표를 다시 연결
* SELECT문을 사용하지만, <br>기본키와 그것을 참조하고 있는 외래키는 같다.</br>라는 조건을 붙혀줘야 함
* ex: SELECT 매출.보고서코드, 일자, 매출.수출처코드, 수출처명, 매출명세.상품코드, 상품명,단가 수량 FROM 매출, 매출명세, 상품, 수출처 WHERE 매출.보고서코드 = 매출명세.보고서코드 AND 매출명세.상품코드=상품.상품코드 AND 수출처.수출처코드=매출.수출처코드;
* 같은 열의 이름이 존재 -> `표이름.열이름` 으로 표기
* 열의 이름은 , 로 구분

#### 종류
* equi join(이퀴조인): 같은 의미를 나타내고 있는 열들을 이용해 조인방식 -> 같은 값을 가지는 행을 조인 조건으로 지정해 연결
* natural join(자연조인): 중복하는 열들을 하나로 정리하는 조인방식
* inner join(이너조인): 공통적인 행만을 선택해 합치는 조인 방식
* outer join(외부조인): 한쪽의 표로 행 전체를 넘긴 뒤, 다른 표에 없는 행은 NULL값으로 지정하는 조인 방식 (왼쪽 테이블로 넘긴경우: 좌외부조인, 오른쪽 테이블로 넘긴경우: 우외부조인)


### CREATE TABLE
* 테이블 생성
* 열의 속성(이름, 자료형, 데이터 범위) 지정, 기본키, 외래키 설정
* ex: CREATE TABLE 상품 (상품코드 NUMBER(3,0), 상품명 CHAR(20), 단가 NUMBER(10,0), PRIMARY KEY(상품코드));

#### 테이블 설정
* PRIMARY KEY: 기본키 설정
* UNIQUE: 유일성 설정
* NOT NULL: NULL값 허용 X
* CHECK: 범위 혹안
* DEFAULT: 디폴트값 설정
* FOREIGN KEY/REFERENCES: 외래키 설정

### INSERT
* 테이블에 데이터(레코드) 추가
* ex: INSERT INTO 상품(상품코드, 상품명, 단가) VALUES(101,'멜론',800);

* 이미 동일한 기본키를 가진 레코드가 존재하는 경우 추가 불가능

### UPDATE
* 테이블의 데이터(레코드) 갱신
* ex: UPDATE 상품 SET 상품명='머스크멜론' WHERE 상품명='멜론';

### DELETE
* 테이블의 데이터(레코드) 삭제
* ex: DELETE FROM 상품 WHERE 상품명='앵두';
