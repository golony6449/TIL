# 만화로 쉽게 배우는 암호

## 암호의 기초

* 암호기술: 통신(전송)에서 데이터의 위-변조를 방지하는 기술

* 기본 모델: 송신자 ->(암호화)-> 인터넷 ->(복호화)-> 수신자

* 용어
1. 평문(Plain text): 보통의 글
2. 암호문(Cipher text): 암호화 된 글
3. 암호화(Encryption): 평문을 암호문으로 바꾸는 것
4. 복호(화)(Decryption): 암호문을 평문으로 바꾸는 것
5. 암호화키(Ek)(Encryption Key)(=비밀키): 암호화에 사용되는 키(암호화 알고리즘에 사용 되는 데이터)
6. 복호(화)키(Dk)(Decryption Key): 복호(화)에 사용되는 키

## 고전적인 암호 기술
### 1. 시저암호 (= 순환암호(sift암호))
* 평문의 각 문자를 순서대로 n문자 옮겨 암호화 하는 알고리즘
* 이때, 알파벳 범위를 벗어나면 나머지연산을 수행해 조정
* 주) 나머지 연산의 결과값 x는 <br>0 < x < b(나누는 값)</br> 이여야 함

* n=3일때, ABCDE -> DEFGH

* 암호화키: n(숫자)

### 2. 환자식암호(=대입암호)
* 시저 암호를 복잡하게 해서, 각 문자마다 옮기는 숫자를 변화 시킨 것.
* 일정한 변환규칙 ∂(시그마)에 따라 평문을 암호문으로 암호화
* 이때, 각 문자를 1:1로 다른 문자에 대응시키는 것을 '단일환자암호'라고 함 -> 시저암호도 단일환자암호의 일종
* 암호화키: ∂

### 3. 다표식암호
평문을 n문자 씩 블록으로 나누고, 각 블록 안에서 <b>문자를 옮기는 수를 바꾸는</b> 알고리즘

예시)

n=4, delta={1st->2문자, 2nd->5문자, 3rd->3문자, 4th->1문자}

MOMOTARO -> MOMO/TARO -> OTPP/VFUP -> OTPPVFUP

암호화키: n, delta

### 4. 전치식 암호
평문을 n문자 씩 블록으로 나누고, 각 블록 안에서 <b>문자의 순서를 바꾸는</b> 알고리즘

예시)

n=4, tau={1st->2nd, 2nd->4th, 3rd->1st, 4th->3rd}

MOMOTARO -> MOMO/TARO -> MMOO/RTOA -> MMOORTOA

* ex: 애너그램(단, n은 문자전체) 

##### 애너그램
* 원문의 문자 순서를 변경해 암호 생성. 단순히 순서를 변경할 수도 있으나, 다른 뜻을 가지는 단어로 변형하기도 함
* dormitory -> dirty room, earth -> heart

* 생성가능한 암호 수(예시: 원문: 암호책)
1. 원문의 문자를 분해 -> ㅇㅏㅁㅎㅗㅊㅐㄱ -> ㅇㅁㅎㅊㄱ, ㅏㅗㅐ
2. 자음 5개중 3개(문자 갯수=모음수)를 뽑아 배치(순서에 따라 다른 단어가 됨 -> 순열을 이용)
3. 모음 3개를 배치 -> 3!
4. 나머지 자음을 2개를 3곳중에서 순서있게 배치
* -> 총 2160개(5P3 * 3! * 3!)

## 암호의 안전성
키의 수 = 암호 해독에 필요한 최대의 시행착오 수
=> 키의 수가 많은 수록 

### 시저암호의 키의 수
영어 알파벳 수 = 26 = 키의 total 수

-> 최대 26번의 시행착오면 해독 가능

### 환자식 암호의 키의 수
26개의 알파벳에 26개의 알파벳을 매칭 -> 26P26 순열의 경우의 수

1초에 1억개씩 탐색해도, 1280억년 소요 -> 계산적으로 안전한 암호 but, 빈도분석에는 약함

빈도분석 - 평문에 등장하는 문자의 출현빈도, 암호문에 등장하는 문자의 출현빈도가 일치하는 특징을 이용한 분석법

### 다표식암호의 키의 수
블록 내에서 1개의 문자가 이동 가능한 경우의 수 26

-> 블록크기가 n인 블록의 total 키의 수 = 26**n

-> n이 클수록 total 키의 수 증가

예시)

블록 크기가 4인 블록의 total 키의 수 = 26**4

### 전치식 암호의 키의 수
* 블록 크기가 n인 블록의 total 키의 수는 n!
* 즉, n이 클수록 키의 total 수 증가 

### 해독이 가능해지는 조건
1. 암호화 알고리즘이 알려져 있는 경우
2. 치우침(문자의 출현률)과 같은 통계적 성질의 데이터가 있는 겅우
3. 암호화의 예문을 많이 가지고 있는 경우

* 암호문이 길수록 단서 증가 -> 해독 난이도 하락

### 절대 안전한 암호
* 이론상 해독 불가능한 암호
* 버넘암호: 평문에 길이가 같은 난수의 줄을 덧붙혀 암호문 C 만듦, 1회성 난수키를 이용하기 때문에 해독 불가능

암호화
1. 알파벳을 문자 코드로 전환 (M->12, O->14)
2. 1회만 사용하는 난수를 가산 (12+9 -> 21), 14+20 -> 34)
3. 26으로 나눈 나머지 계산 (21 -> 21, 34 -> 8)
4. 문자코드를 이용해 알파벳으로 변환 (21->V, 8-> I)

* 단점: 키가 너무 길어서 효율이 떨어짐

### 안전한 암호
1. 절대 안전한 암호
2. <b>계산적으로 안전한 암호: 해독하는 데 채산이 맞지 않을 정도로 수고, 시간 소요.</b> (현대의 상용 암호에 사용됨)

## 공통키 암호화 (= 대칭키 암호(Common Key Cryptography), 비밀키 암호(Symmetric Key Cryptography))
* 암호화, 복호화에 같은 키를 사용하는 알고리즘
* 0x : 16진수를 의미하는 기호

XOR을 이용해 암호화, 복호화 가능
1. 평문 XOR 암호키 = 암호문 (암호화)
2. 암호문 XOR 암호키 = 평문 (복호화)

노드들의 간선 수 만큼 암호키가 필요

(n개 노드일때, nC2개의 암호 키 필요)

특징
1. 키의 전송, 보관에 특히 유의해야 함
2. 계산량 적음 -> 고속의 암호화, 복호화 수행가능하기 때문에 대량의 데이터 통신에 적함
3. 다수와 통신시 대량의 키가 필요 -> 불특정 다수와의 통신에는 적합하지 않음

암호방식
1. 스트림암호(축차암호)
2. 블록암호

두 방식 모두 언젠가는 키를 찾을 수 있음

-> 계산적인 안전성보증만 가능

### 스트림 암호
축차적으로 암호화, 복호화 수행

평문 데이터와 키를 차례로 XOR 연산

키: 의사난수열(아무 의미 없는 수의 나열)

블록 암호에 비해 단순한 조작 -> 고속처리 가능

예시) RC4, SEAL

### 블록암호
일정한 길이의 블록마다 암호화

#### 블록, 키 길이
1. DES: 블록 길이: 64비트, 키의 길이: 64
2. AES: 블록 길이: 128비트, 키의 길이: 128, 192, 256

블럭이 가득 차지 않고 비어있는 경우 - 패딩(Padding)을 더해 블록길이에 맞춰줌. 이때, 패딩은 추가한 패딩 수를 값으로 가짐

* ECB(Electric Code Book) 모드

각 블록을 독립된 것으로 하여 개별적으로 암호화, 복호화 하는 방식

* CBC(Cipher Block Chaining) 모드

블록 단위 안에 중복된 데이터가 있을 때, 암호문에도 중복이 발생하는 문제 해결을 위한 방식

입력 or 출력 데이터의 일부 블록을 피드백 시켜 암호 강도 증대

### DES 암호
* 세계 최초의 상용암호
바탕: 루시퍼암호 (by 호스트 파이스텔)

#### 파이스텔형 암호의 기본 구성
1. 평문을 64비트씩 블록으로 분할
2. 블록에 초기치환 실행 -> 비트의 위치를 뒤섞음
3. 32비트씩 2개로 분할(L0, R0)
4. 암호화 키(K0)와 f(비선형함수)로 R0를 환자, 치환 처리
5. 4번 처리를 한 R0와 L0에 XOR 연산을 하고 이를 R1(새로운 우측블록)으로 저장
6. 원래의 R0를 L1으로 저장
7. 4,5 단계를 2~15라운드 까지 반복 (총 16라운드)
8. 오른쪽비트(R16), 왼쪽비트(L16)를 64비트로 재구성
9. 초기치환을 거꾸로 하는 처리(IP**-1) 수행
10. 암호화 완성

* 해독방지 변환처리: 대합

2회 변환할 경우 원래상태로 돌아가는 변환을 의미

DES와 루시퍼암호의 차이: 키의 길이
* DES는 루시퍼에 비해 짧은 키 길이 가짐 

DES: 64비트(키: 56비트, 패리티체크: 8비트)

루시퍼: 블록길이 64bit, 키 길이 112bit

이유: NSA에서 키의 후보 수 제한

#### DES의 암호화 키 생성
암호화에 사용되는 키(K0~K16)는 매 회전마다 서로 다르게 생성
1. 64비트의 초기 키(K)에서 패리티비트(8bit)를 제외하고 선택치환 수행
2. 선택치환 결과문(56bit)를 왼쪽(C0), 오른쪽(D0) 비트로 나눔
3. C0, D0를 어느 비트 수 만큼 왼쪽순회시프트(LS1)해 이것을 C1, D1 로 함
4. C1 + D1 이후 8bit를 제외한 채, 압축치환(PC-2)를 수행한 48bit를 k1으로 함
5. 3, 4를 1사이클로 해서, Kn 생성

* 복호키 생성: 오른쪽순회시프트 사용, K16 -> K1 순으로 얻음

#### DES의 비선형함수 f 의 구조
입력: Rn-1 (32bit)
1. 입력된 왼쪽 32bit 데이터를 키에 맞게끔 48비트로 확대치환 수행 (ERn-1)
2. 확대치환된 데이터를 키로 XOR 연산 수행 (Kn XOR ERn-1)
3. XOR 연산결과를 6bit 씩 8개로 나눔
4. 나눠진 6bit 데이터를 각각 S-Box1~8 까지의 박스를 통해 4bit로 변환
5. 4bit로 변환된 데이터를 순번에 따라 결합해 32bit 데이터로 재구성
6. 출력치환(PS) 수행
7. 출력 

#### 블록암호 해독방법
1. 전주조사해독법: 가능한 모든 경우의 키를 조사
2. 차분해독법: 입력차분이 그대로 출력차분이 되는 XOR연산의 성질을 이용해 키를 찾는 방법
3. 선형해독법: S-Box를 선형근사(일차함수의 직선에 근사)시켜 확률적으로 출력 추정

* <b>DES암호는 전주조사해독법, 선형해독법으로 1990s에 해독됨 </b>

=> 새로운 암호 등장...

### 3-DES, AES 암호
#### 3-DES
* 키를 3회 사용해 암호화

* case
1. 최초의 암호화 - 복호화에 같은키 사용 -> 두전째 암호화에 어떤 키를 사용해도 DES와 동일
2. 최초 암호화, 2번째 암호환에 같은키 사용, 복호화에 다른키 사용 -> 56*2= 112bit의 키 길이
3. 모두 다른 키 사용 -> 56*3=168bit의 키 길이

##### 문제점
* 키의 길이가 길어진 DES -> 근본적인 해결책 X

#### AES (Advanced Encryption Standard)
* 레인달(Rijndael) 알고리즘 도입

##### 종류
| 종류 | 키의 길이(비트) | 블록 길이(비트) | 단수 |
|------|---------------|-----------------|------|
| AES-128 | 128 | 128 | 10 |
| AES-192 | 192 | 128 | 12 |
| AES-256 | 256 | 128 | 14 |

* 키의 길이가 길수록, 회전 수가 많을수록 강도 세짐

##### 암호화 과정
1. 평문 -> 수 변환 -> 행렬에 배치
2. 수에 비밀키를 더함
3. 각 수들을 규칙에 의해 다른수로 변환
4. 행렬의 행에 있는 수들을 규칙에 의해 자리를 변경
5. 행렬의 열에 있는 수들을 규칙에 의해 다른 수들로 바꿈
6. 수에 비밀키를 더함
7. 3~6단계 반복 (10 or 12 or 14회)
8. 5번 단계를 제외하고 7번 과정을 1회 수행
