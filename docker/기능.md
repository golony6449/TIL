# 기능

## 주요기능

1. 이미지 만들기(Build)
2. 이미지 공유 (Ship)
3. 컨테이너 동작 (Run)

### 이미지 만들기 (Build)

* 하나의 이미지에는 1개의 어플리케이션만!
* 여러개의 이미지를 겹쳐서 새로운 이미지 생성 가능! (이때는 변경이 있는 부분을 차분해서 레이어로 관리)
* Docker Engine, Docker Compose



### 이미지 공유 (Ship)

* 도커 레지스트리를 통해 이미지를 공유할수 있음
* 공식 레지스트리: Docker Hub
* Automated Build: Github, Bitbucket 상의 Dockerfile을 이용해 이미지 빌드/공유
* 공유전에 공유자의 비밀키를 이용해 서명 ==> 다운받는 사람을 공개키를 이용해 검증
* 알려진 보안 취약점을 Docker Security Scanning에서 검사
* Docker Registry



### 컨테이너를 동작 (Run)

* 이미지를 이용해 컨테이너 구동
* 컨테이너 내의 프로세스를 그룹단위로 관리, 다른 그룹의 파일/프로세스에는 접근할 수 없음 (이를 위해 namespace, cgroup 사용)
* 대개 컨테이너는 가용성, 분산처리 등을 위해 여러대의 호스트로 구성된 분산환경에서 구동 ==> 오케스트레이션 툴 사용
* Docker Engine, Docker Compose, Docker Machine, Docker Swarm



## Docker의 기반 기술

### namespace - 컨테이너 구획화

* 독립된 환경(컨테이너) 구성에 사용
* 충돌가능성 감소, 쉬운 참조 가능
* 이름공간이 다를경우, 동일한 이름이라도 다른 실체로 간주함

#### 종류

* PID(Namespace가 다른 프로세스는 접근불가)
* Network(호스트상에서 사용중인 포트도 컨테이너 내에서 사용 가능)
* UID(사용자, <b>권한</b> 격리)
* MOUNT(마운트한 저장소 격리)
* UTS
* IPC(호스트 상에서 컨테이너 격리)



### cgroups - 자원관리

* 컨테이너에 할당되는 자원관리
* 프로세스, 스레드를 그룹화 ==> 해당 그룹 할당되는 자원 제한
* 할당되는 자원량관리를 통해 QoS 보장, 우선순위 설정 가능
* 관리가능한 자원: cpu(사용량), cpuacct(사용량 통계), cpuset(CPU, 메모리의 배치), memory(메모리, 스왑 사용량), devices(외부장치에 대한 접근) freezer(그룹에 속한 프로세스 정지/재개), net_cfs(네트워크 제어 그룹), blkio(블록 디바이스 입출력량)



### 네트워크 구성

* 서버의 물리 NIC를 docker0(가상브릿지)와 연결
* NIC - docker0간 통신에 NAPT(=IP 마스커레이드) 사용
* 컨테이너 시작시 파라메터를 이용해 특정 포트를 해당 컨테이너에 개방 (이때 NIC상 포트와 컨테이너상의 포트를 다르게 설정 가능)
* NAT와 다른점: NAT는 IP만을 변환, NAPT는 IP+포트까지 변경(==> IP마다 송수신포트가 다르기 때문에 동시에 여러 클라이언트가 통신할 수 있음)



### Docker 이미지의 데이터 관리

* Docker에서는 Copy on Write 방식(복사요청시 바로 복사하는 것이 아니라, 원본/사본이 수정되는 시점에 실제 복사 수행) 사용
* 사용하는 시스템
* AUFS(파일/디렉토리를 투과적으로 겹쳐서 파일트리 구성)
* Btrfs(롤백, 스냅샷기능)
* Device Mapper(블록 장치 드라이버 + 라이브러리, thin-provisioning, 스냅샷 기능), 
* OverlayFS: 하나의 파일 시스템에 다른 FS를 투과적으로 머징
* ZFS: 볼륨관리, 스냅샷, 체크섬처리, 레플리케이션 기능 포함