# 리팩토링 and 테스트

## 클린코드
* 깨진유리창 이론 ==> 기술부채의 문제
* Code Smell: 잠재적으로 문제가 될 수 있는 코드, 3줄이상의 내용이 중복
* 보이스카우트 규칙: 처음왔을때 보다 깨끗하게 할것

* guardClause: 문제 발생시 바로 리턴하는 디자인패턴
* None Object의 활용: 복잡한 조건의 간소화

* Bool, Object에서 None, False 체크의 경우 `not` 키워드(Syntax Sugar) 사용, Syntax Salt 지양)

* 예외처리 진행 or 유효성 오류의 경우 NoneObject 반환 ==> 에러 체크 횟수 감소

* 짧은 조건은 삼항연산자

* 단순한 IF, SWITCH는 Dictionary를 이용해 간소화

* 함수이름은 snake_case, 행동을 이름의 가장 앞에 명명

* 주석이 필요한 복잡한 로직 ==> 여러 함수로 분리, 함수 명을 주석 대신 사용 (주석이 없어도 이해할 수 있는 코드가 좋은코드)

* 함수의 인수는 3개 이하

* 클래스, 함수에 너무 많은 내용을 주기 말 것

* 한 파일에는 1개의 클래스만!

## 테스트 and 리펙토링
* 모듈, 비즈니스, 통합 단계의 구성에서 모듈 추가시 해당 코드에 문제가 있으면 큰 사이트이펙트 발생
* ex: 모듈 추가 이후, API의 인수에 따라 에러 발생 등
* 코드 추가에 대한 부담 증가 ==> 테스트코드의 필요성

* 테스트는 Bottom-Up, 리팩토링은 Top-Down

* 순수함수: 입력에 의해 출력 값이 결정, 입력이외의 요소는 출력에 영향을 주지 않음 ==> 테스트 진행에 적절

### 테스트
* 단위 테스트: 메소드, 함수를 <b> 세부적으로</b>
* 통합테스트: 코드집합(메소드, 메소드의 모음)을 전체적으로 테스트, 기능위주 테스트
* End-To-End(E2E) 테스트: UI(=사용자)관점에서의 테스트

### 화이트박스 테스트
### 블랙박스 테스트

### 순수함수의 테스트
* unittest 모듈 사용 (unittest.TestCase를 상속받아 케스트 정의)
* 입력과 해당 결과값을 매칭 (테스트 케이스: target, Given, Expected)
* 순수함수가 적합 (입력에 따른 출력값 검증)

### 비 순수함수의 테스트
* 테스트를 위한 데이터를 별도로 삽입

## TDD and 딜레마
* 일반적인 개발과 차이점: 더 짧은 개발 주기, 테스트 코드 먼저 작성 --> 코드 작성
* No silver bullet: 요구사항 fix 필요, 자동화(CI환경) 필요